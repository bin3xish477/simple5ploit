from platform import system
from os import listdir
from os import remove
from os import geteuid
from os.path import isfile
from os.path import abspath
from os.path import dirname
from os.path import sep
from os.path import basename
from shutil import rmtree
from prompt_toolkit.completion import NestedCompleter
from prompt_toolkit.styles import Style
from prompt_toolkit import PromptSession
from prompt_toolkit.history import InMemoryHistory
from prompt_toolkit.auto_suggest import AutoSuggestFromHistory
from inspect import getmembers
from inspect import isclass
from imp import load_source
from .base import Exploit
from sys import exit
from sys import executable
from tabulate import tabulate
from subprocess import run as sh
from subprocess import Popen as proc_open
from subprocess import PIPE
from subprocess import CalledProcessError
from time import sleep

OS = system()

class cli:
    _help_ = {
        "help": "show this help menu",
        "list": "list all available exploits",
        "search": "use search string to find exploits",
        "select": "select an exploit",
        "sh": "run shell command on local system",
        "cls": "clear screen",
        "back": "go back to previous menu",
        "exit": "exit program"
    }

    def __init__(self):
        self.exploits_path = dirname(abspath(__file__)).replace("/internal", "")
        self.exploits = [f.rstrip(".py")
                    for i, f in enumerate(listdir(self.exploits_path))
                    if isfile(f"{self.exploits_path}{sep}{f}")
                    and f not in (basename(__file__), "base.py")]
        self.style = Style.from_dict({
            "prompt": "#ff0000"
        })

    def list(self):
        print("Exploits:")
        for exploit in self.exploits:
            print(f"\t\u2022 {exploit}")
        print()

    def select(self, exploit):
        mod = __import__(f"modules.exploits.{exploit}", fromlist=["exp"])
        exploit_class = [c for (_,c) in getmembers(mod, isclass)
                        if issubclass(c, Exploit) & (c is not Exploit)][0]
        return self.exploit_prompt(exploit_class())

    def exploit_prompt(self, cls):
        exploit_args_dict = {arg: None
                for arg in cls.args.keys()}
        exploit_menu_dict = {
            "help": None,
            "options": None,
            "info": None,
            "set": exploit_args_dict,
            "unset": exploit_args_dict,
            "sh": None,
            "check": None,
            "run": None,
            "get": None,
            "cls": None,
            "back": None,
            "exit": None
        }

        exploits_help_menu = {
            "help": "show this help message",
            "options": "show exploit options",
            "info": "show general exploit information",
            "set": "set value",
            "unset": "unset value",
            "sh": "run shell command on local system",
            "check": "check if target is vulnerable",
            "run": "run exploit",
            "get": "install exploit dependencies",
            "cls": "clear screen",
            "back": "go back to previous menu",
            "exit": "exit program"
        }

        exploit_menu = NestedCompleter.from_nested_dict(exploit_menu_dict)
        message = [("class:prompt", cls.prompt)]
        while True:
            try:
                selected = self.session.prompt(
                    message,
                    style=self.style,
                    completer=exploit_menu,
                    complete_while_typing=False
                ).strip()
            except KeyboardInterrupt:
                print("Press [CTRL+D] to exit")
                continue
            except EOFError:
                print("❌❌❌ Goodbye ❌❌❌")
                exit(1)

            if selected == "": continue 
            elif selected == "help":
                table = tabulate(
                        [[k, v] for k, v in exploits_help_menu.items()],
                        headers=["Command", "Description"],
                        tablefmt="fancy_grid")
                print(table)
            elif selected == "options":
                table = tabulate(
                        [[arg, cls.__dict__[arg]] for arg in cls.args.keys()],
                        headers=["Argument", "Value"],
                        tablefmt="fancy_grid")
                print(table)
            elif selected == "info":
                table = tabulate([[k, v] for k, v in cls.info.items()],
                        headers=["Key", "Value"],
                        tablefmt="fancy_grid")
                print(table)
            elif selected.startswith("unset"):
                cls.__dict__[select.split()[-1].strip()] = ""
            elif selected.startswith("set"):
                selected = selected.split()
                if len(selected) < 2:
                    print("the `set` command must be proceeded with an argument and value")
                    print("\nexample:\n\tset url http://localhost:8080")
                    continue
                arg, val = selected[1].strip(), " ".join(selected[2:])
                cls.__dict__[arg] = val
            elif selected == "check":
                try:
                    cls.check()
                except NotImplementedError:
                    print(f"The author of ```{cls.__class__.__name__}``` did not implement a check functionality for this module")
            elif selected == "run":
                all_set = True
                for arg, values in cls.args.items():
                    if values["required"] and (
                        not cls.__dict__[arg]
                        or cls.__dict__[arg].lower() == "n/a"):
                        print("!"*70)
                        print(f"``{arg}`` must be set before running this exploit")
                        all_set = False
                if all_set:
                    try:
                        cls.run()
                    except NotImplementedError:
                        print("[X] This exploits `run` function has not been implemented")
                    except ImportError:
                        print("[X] An import error occured. Run `get` to install exploit dependencies")
                    except:
                        print("[X] An error occurred while running the exploit")
            elif selected == "get":
                if isfile("./setup.py"):
                    remove("./setup.py")
                if OS in ("Linux", "Darwin") and geteuid() != 0:
                    print("The `get` command requires root privileges")
                    print("run simple5ploit")
                    continue
                dependency_list = str(cls.pip_dependencies).replace("\"", "")
                with open("./setup.py", "w") as f:
                    f.write(
                        f"from setuptools import setup\n" \
                        f"setup(install_requires={dependency_list})\n")
                    try:
                        print("[*] Fetching pip dependencies...")
                        proc_open(
                                [f"{executable}", "./setup.py", "install"],
                                stderr=PIPE)
                        print("[*] Dependencies successfully installed...")
                    except:
                        print("[X] An error occured install dependencies")
                    finally:
                        rmtree("build", ignore_errors=True)
                        rmtree("dist", ignore_errors=True)
                        rmtree("UNKNOWN.egg-info", ignore_errors=True)
            elif selected.startswith("sh"):
                cmd = selected.split()[1:]
                if cmd:
                    try:
                        out = sh(cmd, capture_output=True).stdout
                    except:
                        cmd = ' '.join(cmd)
                        print(f"unable to run command: `{cmd}`")
                        continue
                    print(out.decode("utf8"))
                else: print("`sh` command used but no shell command was specified")
            elif selected == "cls":
                print("\n"*75)
            elif selected == "back":
                break
            elif selected == "exit":
                print("❌❌❌ Goodbye ❌❌❌")
                exit(0)
            else:
                print(f"`{selected}` is not a valid command! Type `help` for help menu")

    def help(self):
        print(self._help_)

    def init(self):
        menu = NestedCompleter.from_nested_dict({
            "help": None,
            "list": None,
            "search": None,
            "select": {exploit: None for exploit in self.exploits},
            "sh": None,
            "cls": None,
            "back": None,
            "exit": None
        })

        self.session = PromptSession(
                complete_while_typing=False,
                auto_suggest=AutoSuggestFromHistory()
        )
        message = [("class:prompt", "〔Exploits〕❯ ")]
        while True:
            try:
                selected = self.session.prompt(
                    message,
                    style=self.style,
                    completer=menu,
                ).strip()
            except KeyboardInterrupt:
                print("Press [CTRL+D] to exit")
                continue
            except EOFError:
                print("❌❌❌ Goodbye ❌❌❌")
                exit(1)

            if selected == "list":
                self.list()
            elif selected.startswith("search"):
                s = ' '.join(selected.split()[1:])
                print("Matched Exploits:")
                for exploit in self.exploits:
                    if s in exploit:
                        print(f"\t* {exploit}")
                print()
            elif selected.startswith("select"):
                selected = selected.split()
                if len(selected) == 1 or selected[-1] == "":
                    print("Must provide an exploit by name to use, try `list` command")
                    continue
                exploit = selected[-1].strip()
                if exploit not in self.exploits:
                    print(f"{exploit} is not a valid exploit, try `list` command")
                    continue
                self.select(exploit)
            elif selected == "help":
                table = tabulate([[k, v] for k, v in self._help_.items()],
                        headers=["Command", "Description"],
                        tablefmt="fancy_grid")
                print(table)
            elif selected.startswith("sh"):
                cmd = selected.split()[1:]
                if cmd:
                    try:
                        out = sh(cmd, capture_output=True).stdout
                    except:
                        cmd = ' '.join(cmd)
                        print(f"unable to run command: `{cmd}`")
                        continue
                    print(out.decode("utf8"))
                else: print("`sh` command used but no shell command was specified")
            elif selected == "cls":
                print("\n"*75)
            elif selected in ("back"):
                break
            elif selected == "exit":
                print("❌❌❌ Goodbye ❌❌❌")
                exit(0)
            else:
                print(f"`{selected}` is not a valid command! Type `help` for help menu")
