from platform import system
from os import listdir
from os import remove
from os import geteuid
from os.path import isfile
from os.path import abspath
from os.path import dirname
from os.path import sep
from os.path import basename
from shutil import rmtree
from prompt_toolkit.completion import NestedCompleter
from prompt_toolkit.styles import Style
from prompt_toolkit import PromptSession
from prompt_toolkit.history import InMemoryHistory
from prompt_toolkit.auto_suggest import AutoSuggestFromHistory
from inspect import getmembers
from inspect import isclass
from .base import Exploit
from sys import exit
from sys import executable
from tabulate import tabulate
from time import sleep
from subprocess import run as sh

OS = system()

class cli:
    _help_ = {
        "help": "show this help menu",
        "list": "list all available exploits",
        "search": "use search string to find exploits",
        "select": "select an exploit",
        "sh": "run shell command on local system",
        "cls": "clear screen",
        "back": "go back to previous menu",
        "exit": "exit program"
    }

    def __init__(self, exploit=None):
        if exploit:
            self.exploit = exploit.replace("exploit::", '')
        else:
            self.exploit = exploit
        self.exploits_path = dirname(abspath(__file__)).replace("/internal", "")
        self.exploits = [ f.rstrip(".py")
            for f in listdir(self.exploits_path)
            if isfile(f"{self.exploits_path}{sep}{f}") ]
        self.style = Style.from_dict({
            "prompt": "#ff0000"
        })

    def list(self):
        print("Exploits:")
        for exploit in self.exploits:
            print(f"\t\u2022 {exploit}")
        print()

    def select(self, exploit):
        mod = __import__(f"simple5ploit.modules.exploits.{exploit}", fromlist=["exp"])
        exploit_class = [c for (_,c) in getmembers(mod, isclass)
                        if issubclass(c, Exploit) & (c is not Exploit)][0]
        self.exploit = None
        self.exploit_prompt(exploit_class())

    def exploit_prompt(self, cls):
        exploit_args_dict = {arg: None
                for arg in cls.args.keys()}
        exploit_menu_dict = {
            "help": None,
            "options": None,
            "info": None,
            "set": exploit_args_dict,
            "unset": exploit_args_dict,
            "sh": None,
            "check": None,
            "run": None,
            "depends": None,
            "get": None,
            "cls": None,
            "back": None,
            "exit": None
        }

        exploits_help_menu = {
            "help": "show this help message",
            "options": "show exploit options",
            "info": "show general exploit information",
            "set": "set value",
            "unset": "unset value",
            "sh": "run shell command on local system",
            "check": "check if target is vulnerable",
            "run": "run exploit",
            "depends": "shows the dependencies needed for this exploit",
            "get": "install exploit dependencies",
            "cls": "clear screen",
            "back": "go back to previous menu",
            "exit": "exit program"
        }

        exploit_menu = NestedCompleter.from_nested_dict(exploit_menu_dict)
        message = [("class:prompt", cls.prompt)]
        while True:
            try:
                selected = self.session.prompt(
                    message,
                    style=self.style,
                    completer=exploit_menu,
                    complete_while_typing=False
                ).strip()
            except KeyboardInterrupt:
                print("[!!]::press (CTRL+D) to exit")
                continue
            except EOFError:
                print("❌ Goodbye ❌")
                exit(1)

            if selected == "": continue 
            elif selected == "help":
                table = tabulate(
                        [[k, v] for k, v in exploits_help_menu.items()],
                        headers=["Command", "Description"],
                        tablefmt="fancy_grid")
                print(table)
            elif selected == "options":
                table = tabulate(
                        [[arg, cls.__dict__[arg]] for arg in cls.args.keys()],
                        headers=["Argument", "Value"],
                        tablefmt="fancy_grid")
                print(table)
            elif selected == "info":
                table = tabulate([[k, v] for k, v in cls.info.items()],
                        headers=["Key", "Value"],
                        tablefmt="fancy_grid")
                print(table)
            elif selected.startswith("unset"):
                cls.__dict__[selected.split()[-1].strip()] = "N/a"
            elif selected.startswith("set"):
                selected = selected.split()
                if len(selected) < 2:
                    print("[!!]::the `set` command must be proceeded with an argument and value")
                    print("\nexample:\n\tset url http://localhost:8080")
                    continue
                arg, val = selected[1].strip(), " ".join(selected[2:])
                cls.__dict__[arg] = val
            elif selected == "check":
                try:
                    cls.check()
                except NotImplementedError:
                    print(f"[!!]::```{cls.__class__.__name__}``` exploit has no check function")
            elif selected == "run":
                all_set = True
                for arg, values in cls.args.items():
                    if values["required"] and (
                        not cls.__dict__[arg]
                        or cls.__dict__[arg].lower() == "n/a"):
                        print("!"*70)
                        print(f"``{arg}`` must be set before running this exploit")
                        all_set = False
                if all_set:
                    try:
                        cls.run()
                    except NotImplementedError:
                        print("[XX]::This exploits `run` function has not been implemented")
                    except ImportError:
                        print("[!!]::an import error occured. Run command, `depends`, to get script dependencies")
                        print("[**]::then run the command, `get`, to install the required dependencies")
                    except Exception as e:
                        print(f"[ERROR]::{e}")
            elif selected == "depends":
                if cls.pip_dependencies:
                    print("[************  Dependencies *************]")
                    for dependency in cls.pip_dependencies:
                        print(f"\t\u2022 {dependency}")
                else:
                    print("[!!]::exploit has no dependencies")
            elif selected == "get":
                if cls.pip_dependencies:
                    print("[**]::fetching pip dependencies")
                    from pip._internal.cli.main import main as pip_main
                    [pip_main(["install", pkg]) for pkg in cls.pip_dependencies]
                    print("\n[**]::pip dependencies successfully installed")
                    print("[!!]::try re-running the exploit!!!")
                else:
                    print("[NOTE]::this module does not require any pip dependencies")
            elif selected.startswith("sh"):
                cmd = selected.split()[1:]
                if cmd:
                    try:
                        out = sh(cmd, capture_output=True).stdout
                    except:
                        cmd = ' '.join(cmd)
                        print(f"[XX]::unable to run command: `{cmd}`")
                        continue
                    try:
                        print(out.decode("utf8"))
                    except UnicodeDecodeError:
                        print("[XX]::unable to decode command output!")
                        continue
                else:
                    print("[!!]::`sh` command used but no shell command was specified")
            elif selected == "cls":
                print("\n"*75)
            elif selected == "back":
                break
            elif selected == "exit":
                print("❌ Goodbye ❌")
                exit(0)
            else:
                print(f"[XX]::`{selected}` is not a valid command! Type `help` for help menu")

    def help(self):
        print(self._help_)

    def init(self):
        menu = NestedCompleter.from_nested_dict({
            "help": None,
            "list": None,
            "search": None,
            "select": {exploit: None for exploit in self.exploits},
            "sh": None,
            "cls": None,
            "back": None,
            "exit": None
        })

        self.session = PromptSession(
                complete_while_typing=False,
                auto_suggest=AutoSuggestFromHistory()
        )
        message = [("class:prompt", "〔Exploits〕❯ ")]
        while True:
            if not self.exploit:
                try:
                    selected = self.session.prompt(
                        message,
                        style=self.style,
                        completer=menu,
                    ).strip()
                except KeyboardInterrupt:
                    print("[!!]::press (CTRL+D) to exit")
                    continue
                except EOFError:
                    print("❌ Goodbye ❌")
                    exit(1)

                if selected == "list":
                    self.list()
                elif selected.startswith("search"):
                    s = ' '.join(selected.split()[1:])
                    matched_exploits = []
                    for exploit in self.exploits:
                        if s in exploit:
                            matched_exploits.append(exploit)
                    if matched_exploits:
                        print("Matched Exploits:")
                        for exploit in matched_exploits:
                            print(f"\t* {exploit}")
                        print()
                    else:
                        print(f"[!!]::no exploit names matching: `{s}`")
                elif selected.startswith("select"):
                    selected = selected.split()
                    if len(selected) == 1 or selected[-1] == "":
                        print("[!!]::must provide an exploit by name to use, try `list` command")
                        continue
                    elif len(selected) > 2:
                        print("[!!]::only one exploit can be selected at a time")
                        continue
                    exploit = selected[-1].strip()
                    if exploit not in self.exploits:
                        print(f"[XX]::{exploit} is not a valid exploit, try `list` command")
                        continue
                    self.select(exploit)
                elif selected == "help":
                    table = tabulate([[k, v] for k, v in self._help_.items()],
                            headers=["Command", "Description"],
                            tablefmt="fancy_grid")
                    print(table)
                elif selected.startswith("sh"):
                    cmd = selected.split()[1:]
                    if cmd:
                        try:
                            out = sh(cmd, capture_output=True).stdout
                        except:
                            cmd = ' '.join(cmd)
                            print(f"[XX]::unable to run command: `{cmd}`")
                            continue
                        try:
                            print(out.decode("utf8"))
                        except UnicodeDecodeError:
                            print("[XX]::unable to decode command output!")
                            continue
                            print(out.decode("utf8"))
                    else:
                        print("[!!]::`sh` command used but no shell command was specified")
                elif selected == "cls":
                    print("\n"*75)
                elif selected in ("back"):
                    break
                elif selected == "exit":
                    print("❌ Goodbye ❌")
                    exit(0)
                else:
                    print(f"[XX]::`{selected}` is not a valid command! Type `help` for help menu")
            else:
                self.select(self.exploit)
